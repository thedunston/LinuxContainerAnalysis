/*
 * Test Malware Simulator
 * 
 * This program simulates various malicious behaviors for testing the
 * Linux Malware Analysis Container. It demonstrates behaviors that will
 * be detected by the behavioral analysis patterns.
 * 
 * IMPORTANT: This is for TESTING ONLY in an isolated environment.
 * DO NOT run this on production systems.
 * 
 * Behaviors simulated:
 * - DISCOVERY: System information gathering
 * - EXECUTION: Process creation and shell execution
 * - PERSISTENCE: File creation in persistence locations
 * - DEFENSE_EVASION: Temporary file usage
 * - FILE_OPS: Various file operations
 * - PROCESS: Fork and exec operations
 * - NETWORK: Socket creation (simulated)
 * - STRING_OPS: String manipulation
 * - DIRECTORY: Directory operations
 * - TIME: Time operations
 * - OUTPUT: Print operations
 * - MEMORY: Memory allocation
 * 
 * Compile: gcc -o test_malware_simulator test_malware_simulator.c
 * Run in container: ltrace-full ./test_malware_simulator
 */

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>
#include <time.h>
#include <fcntl.h>
#include <dirent.h>
#include <errno.h>

// Function prototypes
void simulate_discovery();
void simulate_execution();
void simulate_persistence();
void simulate_defense_evasion();
void simulate_file_operations();
void simulate_process_operations();
void simulate_network_operations();
void simulate_string_operations();
void simulate_directory_operations();
void simulate_time_operations();
void simulate_memory_operations();
void simulate_credential_access();

int main(int argc, char *argv[]) {
    printf("===========================================\n");
    printf("  Test Malware Simulator\n");
    printf("  For Linux Malware Analysis Container\n");
    printf("===========================================\n\n");
    
    printf("[*] Starting behavioral simulation...\n\n");
    
    // Simulate various malicious behaviors
    simulate_discovery();
    simulate_file_operations();
    simulate_directory_operations();
    simulate_string_operations();
    simulate_memory_operations();
    simulate_time_operations();
    simulate_execution();
    simulate_process_operations();
    simulate_persistence();
    simulate_defense_evasion();
    simulate_credential_access();
    simulate_network_operations();
    
    printf("\n[*] Simulation complete!\n");
    printf("[*] Check the behavioral analysis report for detected patterns.\n");
    
    return 0;
}

/*
 * DISCOVERY: System and Network Discovery
 * Patterns: uname, hostname, whoami, /etc/passwd, ps
 */
void simulate_discovery() {
    printf("[DISCOVERY] Gathering system information...\n");
    
    char hostname[256];
    char *username;
    FILE *fp;
    char buffer[1024];
    
    // System hostname discovery
    if (gethostname(hostname, sizeof(hostname)) == 0) {
        printf("  [+] Hostname: %s\n", hostname);
    }
    
    // User identity discovery
    username = getenv("USER");
    if (username) {
        printf("  [+] Current user: %s\n", username);
    }
    
    // Read /etc/passwd (Account Discovery)
    fp = fopen("/etc/passwd", "r");
    if (fp) {
        printf("  [+] Reading /etc/passwd...\n");
        int line_count = 0;
        while (fgets(buffer, sizeof(buffer), fp) && line_count < 3) {
            line_count++;
        }
        fclose(fp);
        printf("  [+] Found %d user entries\n", line_count);
    }
    
    // Process discovery simulation
    fp = popen("ps aux | head -5", "r");
    if (fp) {
        printf("  [+] Enumerating processes...\n");
        while (fgets(buffer, sizeof(buffer), fp)) {
            // Just read, don't print all
        }
        pclose(fp);
    }
    
    printf("\n");
}

/*
 * EXECUTION: Execute Malicious Code
 * Patterns: fork(), execve(), system(), chmod +x
 */
void simulate_execution() {
    printf("[EXECUTION] Simulating code execution...\n");
    
    // System command execution
    printf("  [+] Executing shell command via system()...\n");
    system("echo 'Test command execution' > /dev/null");
    
    // Create and make file executable
    FILE *fp = fopen("/tmp/test_script.sh", "w");
    if (fp) {
        fprintf(fp, "#!/bin/bash\necho 'Test script'\n");
        fclose(fp);
        
        // Make executable (chmod +x pattern)
        chmod("/tmp/test_script.sh", 0755);
        printf("  [+] Created executable script: /tmp/test_script.sh\n");
    }
    
    printf("\n");
}

/*
 * PERSISTENCE: Establish Persistence Mechanisms
 * Patterns: .bashrc, crontab, .service files
 */
void simulate_persistence() {
    printf("[PERSISTENCE] Simulating persistence mechanisms...\n");
    
    FILE *fp;
    
    // Simulate .bashrc modification
    fp = fopen("/tmp/.bashrc_test", "w");
    if (fp) {
        fprintf(fp, "# Simulated persistence entry\n");
        fprintf(fp, "export PATH=$PATH:/tmp\n");
        fclose(fp);
        printf("  [+] Created .bashrc test file\n");
    }
    
    // Simulate systemd service file creation
    fp = fopen("/tmp/test.service", "w");
    if (fp) {
        fprintf(fp, "[Unit]\n");
        fprintf(fp, "Description=Test Service\n");
        fprintf(fp, "[Service]\n");
        fprintf(fp, "ExecStart=/bin/bash /tmp/test_script.sh\n");
        fclose(fp);
        printf("  [+] Created .service file\n");
    }
    
    // Simulate crontab entry
    fp = fopen("/tmp/crontab_test", "w");
    if (fp) {
        fprintf(fp, "@reboot /tmp/test_script.sh\n");
        fclose(fp);
        printf("  [+] Created crontab test file\n");
    }
    
    printf("\n");
}

/*
 * DEFENSE_EVASION: Evade Detection and Analysis
 * Patterns: /tmp/, /var/tmp/, unlink, rm -rf
 */
void simulate_defense_evasion() {
    printf("[DEFENSE_EVASION] Simulating evasion techniques...\n");
    
    // Use of temporary directories
    FILE *fp = fopen("/tmp/temp_data.dat", "w");
    if (fp) {
        fprintf(fp, "Temporary data\n");
        fclose(fp);
        printf("  [+] Created file in /tmp/\n");
        
        // Delete file (unlink pattern)
        unlink("/tmp/temp_data.dat");
        printf("  [+] Deleted temporary file\n");
    }
    
    // Use /var/tmp
    fp = fopen("/var/tmp/cache.dat", "w");
    if (fp) {
        fprintf(fp, "Cache data\n");
        fclose(fp);
        printf("  [+] Created file in /var/tmp/\n");
        unlink("/var/tmp/cache.dat");
    }
    
    printf("\n");
}

/*
 * FILE_OPS: File Operations
 * Patterns: fopen, fclose, fwrite, fread, fprintf, stat, access, chmod
 */
void simulate_file_operations() {
    printf("[FILE_OPS] Performing file operations...\n");
    
    FILE *fp;
    char buffer[256];
    struct stat file_stat;
    
    // File write operation
    fp = fopen("/tmp/test_file.txt", "w");
    if (fp) {
        fprintf(fp, "Test data written by simulator\n");
        fwrite("Binary data", 1, 11, fp);
        fclose(fp);
        printf("  [+] File write: /tmp/test_file.txt\n");
    }
    
    // File read operation
    fp = fopen("/tmp/test_file.txt", "r");
    if (fp) {
        fread(buffer, 1, sizeof(buffer), fp);
        fclose(fp);
        printf("  [+] File read: /tmp/test_file.txt\n");
    }
    
    // File status check
    if (stat("/tmp/test_file.txt", &file_stat) == 0) {
        printf("  [+] File stat: size=%ld bytes\n", file_stat.st_size);
    }
    
    // File access check
    if (access("/tmp/test_file.txt", F_OK) == 0) {
        printf("  [+] File access check: exists\n");
    }
    
    // Change file permissions
    chmod("/tmp/test_file.txt", 0644);
    printf("  [+] Changed file permissions\n");
    
    // Rename file
    rename("/tmp/test_file.txt", "/tmp/test_renamed.txt");
    printf("  [+] Renamed file\n");
    
    printf("\n");
}

/*
 * PROCESS: Process Operations
 * Patterns: fork, execve, system, popen, waitpid, kill, exit
 */
void simulate_process_operations() {
    printf("[PROCESS] Simulating process operations...\n");
    
    pid_t pid;
    FILE *fp;
    char buffer[256];
    
    // Fork process
    pid = fork();
    if (pid == 0) {
        // Child process
        printf("  [+] Child process created (PID: %d)\n", getpid());
        exit(0);
    } else if (pid > 0) {
        // Parent process
        printf("  [+] Parent process (PID: %d) forked child (PID: %d)\n", getpid(), pid);
        waitpid(pid, NULL, 0);
        printf("  [+] Child process completed\n");
    }
    
    // Popen (pipe command execution)
    fp = popen("echo 'Pipe test'", "r");
    if (fp) {
        fgets(buffer, sizeof(buffer), fp);
        pclose(fp);
        printf("  [+] Executed command via popen\n");
    }
    
    printf("\n");
}

/*
 * NETWORK: Network Operations
 * Patterns: socket, connect, bind, listen, accept, send, recv
 */
void simulate_network_operations() {
    printf("[NETWORK] Simulating network operations...\n");
    
    int sockfd;
    struct sockaddr_in addr;
    
    // Create socket
    sockfd = socket(AF_INET, SOCK_STREAM, 0);
    if (sockfd >= 0) {
        printf("  [+] Socket created (fd: %d)\n", sockfd);
        
        // Prepare address structure
        memset(&addr, 0, sizeof(addr));
        addr.sin_family = AF_INET;
        addr.sin_port = htons(8080);
        addr.sin_addr.s_addr = INADDR_ANY;
        
        // Attempt bind (will likely fail, but triggers pattern)
        if (bind(sockfd, (struct sockaddr*)&addr, sizeof(addr)) < 0) {
            printf("  [+] Bind attempted (expected to fail in isolated env)\n");
        }
        
        close(sockfd);
        printf("  [+] Socket closed\n");
    }
    
    printf("\n");
}

/*
 * STRING_OPS: String Operations
 * Patterns: strcpy, strncpy, strcat, strcmp, strlen, sprintf, memcpy, memset
 */
void simulate_string_operations() {
    printf("[STRING_OPS] Performing string operations...\n");
    
    char buffer1[256];
    char buffer2[256];
    char result[512];
    
    // String copy
    strcpy(buffer1, "Test string");
    printf("  [+] strcpy executed\n");
    
    // Bounded string copy
    strncpy(buffer2, "Another string", sizeof(buffer2) - 1);
    printf("  [+] strncpy executed\n");
    
    // String concatenation
    strcpy(result, buffer1);
    strcat(result, " ");
    strcat(result, buffer2);
    printf("  [+] strcat executed\n");
    
    // String comparison
    if (strcmp(buffer1, buffer2) != 0) {
        printf("  [+] strcmp executed\n");
    }
    
    // String length
    size_t len = strlen(result);
    printf("  [+] strlen executed: %zu characters\n", len);
    
    // Formatted string
    sprintf(buffer1, "Formatted: %d %s", 42, "test");
    printf("  [+] sprintf executed\n");
    
    // Memory operations
    memset(buffer2, 0, sizeof(buffer2));
    memcpy(buffer2, buffer1, strlen(buffer1));
    printf("  [+] memset and memcpy executed\n");
    
    printf("\n");
}

/*
 * DIRECTORY: Directory Operations
 * Patterns: mkdir, rmdir, opendir, readdir, closedir, chdir, getcwd
 */
void simulate_directory_operations() {
    printf("[DIRECTORY] Performing directory operations...\n");
    
    char cwd[1024];
    DIR *dir;
    struct dirent *entry;
    
    // Get current directory
    if (getcwd(cwd, sizeof(cwd)) != NULL) {
        printf("  [+] Current directory: %s\n", cwd);
    }
    
    // Create directory
    if (mkdir("/tmp/test_dir", 0755) == 0) {
        printf("  [+] Created directory: /tmp/test_dir\n");
    }
    
    // Open and read directory
    dir = opendir("/tmp");
    if (dir) {
        printf("  [+] Opened directory: /tmp\n");
        int count = 0;
        while ((entry = readdir(dir)) != NULL && count < 5) {
            count++;
        }
        closedir(dir);
        printf("  [+] Read %d directory entries\n", count);
    }
    
    // Remove directory
    rmdir("/tmp/test_dir");
    printf("  [+] Removed directory: /tmp/test_dir\n");
    
    printf("\n");
}

/*
 * TIME: Time Operations
 * Patterns: time, ctime, localtime, strftime, sleep
 */
void simulate_time_operations() {
    printf("[TIME] Performing time operations...\n");
    
    time_t current_time;
    struct tm *time_info;
    char time_string[100];
    
    // Get current time
    current_time = time(NULL);
    printf("  [+] Current timestamp: %ld\n", current_time);
    
    // Convert to string
    printf("  [+] Time string: %s", ctime(&current_time));
    
    // Convert to local time
    time_info = localtime(&current_time);
    
    // Format time string
    strftime(time_string, sizeof(time_string), "%Y-%m-%d %H:%M:%S", time_info);
    printf("  [+] Formatted time: %s\n", time_string);
    
    // Sleep briefly
    printf("  [+] Sleeping for 1 second...\n");
    sleep(1);
    printf("  [+] Sleep completed\n");
    
    printf("\n");
}

/*
 * MEMORY: Memory Operations
 * Patterns: malloc, calloc, realloc, free
 */
void simulate_memory_operations() {
    printf("[MEMORY] Performing memory operations...\n");
    
    void *ptr1, *ptr2, *ptr3;
    
    // Allocate memory
    ptr1 = malloc(1024);
    if (ptr1) {
        printf("  [+] malloc: allocated 1024 bytes\n");
        
        // Use the memory
        memset(ptr1, 0, 1024);
        
        // Reallocate
        ptr2 = realloc(ptr1, 2048);
        if (ptr2) {
            printf("  [+] realloc: resized to 2048 bytes\n");
            ptr1 = ptr2;
        }
        
        free(ptr1);
        printf("  [+] free: memory released\n");
    }
    
    // Allocate cleared memory
    ptr3 = calloc(10, sizeof(int));
    if (ptr3) {
        printf("  [+] calloc: allocated 10 integers (cleared)\n");
        free(ptr3);
        printf("  [+] free: memory released\n");
    }
    
    printf("\n");
}

/*
 * CREDENTIAL_ACCESS: Credential Theft and Access
 * Patterns: /etc/passwd, /etc/shadow, .ssh/, password
 */
void simulate_credential_access() {
    printf("[CREDENTIAL_ACCESS] Simulating credential access...\n");
    
    FILE *fp;
    char buffer[256];
    
    // Attempt to read /etc/passwd
    fp = fopen("/etc/passwd", "r");
    if (fp) {
        printf("  [+] Accessed /etc/passwd\n");
        fgets(buffer, sizeof(buffer), fp);
        fclose(fp);
    }
    
    // Attempt to read /etc/shadow (will fail without root)
    fp = fopen("/etc/shadow", "r");
    if (fp) {
        printf("  [+] Accessed /etc/shadow\n");
        fclose(fp);
    } else {
        printf("  [+] Attempted to access /etc/shadow (permission denied)\n");
    }
    
    // Check for SSH directory
    DIR *dir = opendir(getenv("HOME"));
    if (dir) {
        printf("  [+] Checked home directory for credentials\n");
        closedir(dir);
    }
    
    // Simulate password-related activity
    char password_test[] = "password";
    printf("  [+] Password-related string operation detected\n");
    
    printf("\n");
}
